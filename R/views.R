# MISTy view composition functions
# Copyright (c) 2020 Jovan Tanevski <jovan.tanevski@uni-heidelberg.de>

#' \strong{Start here:} create a basic view composition with an intraview
#'
#' This function is the first one to be called when building a MISTy workflow,
#' starting from view composition. The initial view describes the intraview of
#' the sample.
#'
#' @param data A \code{data.frame} or a \code{tibble} containing expression
#'     information for all markers of interest (in named columns) for each
#'     spatial unit (in rows).
#' @param unique.id A \code{character} vector. Identifier of the current sample.
#'     If not provided (\code{unique.id = NULL}) then an id is automatically
#'     generated by calculating the md5 hash of \code{table}.
#'
#' @return An initial MISTy view composition containing an \emph{intraview} list
#'     item named described with abbreviation "intra" and \emph{data} as provided
#'     in \code{data} and a \emph{misty.uniqueid} list item containing the
#'     provided or automatically calculated \code{unique.id}. A cache folder for
#'     the sample will be automatically created in the working directory as a
#'     subfolder of \file{.misty.temp/} with the same name as \code{unique.id}.
#'
#' @family view composition functions
#'
#' @export
create_initial_view <- function(data, unique.id = NULL) {
  init.list <- list(intraview = list(abbrev = "intra", data = data))

  misty.uniqueid <- ifelse(is.null(unique.id),
    digest::digest(data, "md5"),
    unique.id
  )

  view <- append(init.list, list(misty.uniqueid = misty.uniqueid))

  # create cache
  cache.location <- paste0(
    ".misty.temp", .Platform$file.sep,
    view[["misty.uniqueid"]]
  )

  if (!dir.exists(cache.location)) {
    dir.create(cache.location, recursive = TRUE, showWarnings = TRUE)
  }

  return(view)
}

# make a misty.view class?

#' Create a custom view
#'
#' Create a custom view from a \code{data.frame} or a \code{tibble}.
#'
#' Creating a custom view does not add it to the current view composition.
#'
#' @param name Name of the view. A character vector.
#' @param data A \code{data.frame} or a \code{tibble} with named variables in
#'     columns and rows for each spatial unit ordered as in the intraview.
#' @param abbrev Abbreviated name. A character vector.
#'
#' @return A new MISTy view. A list with a single \code{name}d item described by
#'     the provided \code{abbrev}iation and \emph{data} containing the provided
#'     \code{data}.
#'
#' @seealso \code{\link[MISTy:add_views]{add_views()}} for adding created views
#'     to a view composition.
#'
#' @family view composition functions
#'
#' @export
create_view <- function(name, data, abbrev = name) {
  new.list <- list(list(abbrev = abbrev, data = data))
  names(new.list)[1] <- name
  return(new.list)
}



#' Add custom views to the current view composition
#'
#' Add one or more custom views to the current view composition.
#'
#' @param current.views the current view composition.
#' @param new.views a view or a list of views created with
#'     \code{\link[MISTy:create_view]{create_view()}} or otherwise.
#'
#' @return A MISTy view composition containing an union of views from
#'     \code{current.views} and \code{new.views}.
#'
#' @seealso \code{\link[MISTy:create_initial_view]{create_initial_view()}} for
#'     starting a view composition, with an intraview,
#'     \code{\link[MISTy:create_view]{create_view()}} for creating a custom view.
#'
#' @family view composition functions
#'
#' @export
add_views <- function(current.views, new.views) {
  assertthat::assert_that(length(current.views) >= 1,
    !is.null(current.views[["intraview"]]),
    !is.null(current.views[["misty.uniqueid"]]),
    msg = "Intraview is missing."
  )

  assertthat::assert_that(is.list(new.views),
    msg = "The new views are not in a list or vector."
  )

  assertthat::assert_that(length(new.views %>% unlist(recursive = F)) %% 2 == 0,
    msg = "The new view is malformed. Consider using create_view()."
  )

  assertthat::assert_that(!any(names(new.views) %in% names(current.views)),
    msg = "The list of new views contains a duplicate view name."
  )

  view.abbrev <- current.views %>%
    rlist::list.remove(c("misty.uniqueid")) %>%
    purrr::map_chr(~ .x[["abbrev"]])

  new.view.abbrev <- new.views %>% purrr::map_chr(~ .x[["abbrev"]])

  assertthat::assert_that(!any(new.view.abbrev %in% view.abbrev),
    msg = "The list of new views contains a duplicate abbreviation."
  )

  new.views %>% purrr::walk(function(new.view) {
    # check for naming of each element, abbreviation and existance of a table
    assertthat::assert_that(is.list(new.view),
      !is.null(new.view[["abbrev"]]),
      is.character(new.view[["abbrev"]]),
      !is.null(new.view[["data"]]),
      (is.data.frame(new.view[["data"]]) | tibble::is_tibble(new.view[["data"]])),
      msg = "The new view is malformed. Consider using create_view()."
    )

    # check for row compatibility
    assertthat::assert_that(nrow(current.views[["intraview"]][["data"]]) ==
      nrow(new.view[["data"]]),
    msg = "The new view should have the same number of rows as the intraview."
    )
  })

  # update
  return(append(current.views, new.views))
}

#' Generate and add a juxtaview to the current view composition
#'
#' The juxtaview captures the expression of all markers within the immediate
#' neighborhood of a spatial unit.
#'
#' The neighborhood of each spatial unit is estimated by constructing a graph by
#' 2D Delaunay triangulation following by removal of edges with length larger than
#' \code{neighbor.thr}. For each spatial unit the juxtaview contains the sum of
#' expressions across its estimated neighbors for each marker.
#'
#' @param current.views the current view composition.
#' @param positions a \code{data.frame}, \code{tibble} or a \code{matrix}
#'     with named coordinates in columns  and rows for each spatial unit ordered
#'     as in the intraview.
#' @param neighbor.thr a threshold value used to indicate the largest distance
#'     between two spatial units that can be considered as neighboring.
#' @param cached a \code{logical} indicating whether to cache the calculated view
#'     after the first calculation and to reuse a previously cached view if it
#'     already exists for this sample.
#' @param verbose a \code{logical} controlling the verbosity of the output of the
#'     function during execution.
#'
#' @return A MISTy view composition with added juxtaview.
#'
#' @seealso \code{\link[MISTy:create_initial_view]{create_initial_view()}} for
#'     starting a view composition with an intraview only.
#'
#' @family view composition functions
#'
#' @export
add_juxtaview <- function(current.views, positions, neighbor.thr = 15,
                          cached = TRUE, verbose = TRUE) {
  # from a deldir object
  get_neighbors <- function(ddobj, id) {
    dplyr::union(
      ddobj$delsgs$ind1[which(ddobj$delsgs$ind2 == id)],
      ddobj$delsgs$ind2[which(ddobj$delsgs$ind1 == id)]
    )
  }

  expr <- current.views[["intraview"]][["data"]]

  cache.location <- paste0(
    ".misty.temp", .Platform$file.sep,
    current.views[["misty.uniqueid"]]
  )

  juxta.cache.file <- paste0(
    cache.location, .Platform$file.sep,
    "juxta.view.", neighbor.thr, ".rds"
  )

  if (cached & file.exists(juxta.cache.file)) {
    message("Juxtaview retrieved from cache\n")
    juxta.view <- readr::read_rds(juxta.cache.file)
  }
  else {
    if (verbose) message("Computing triangulation")
    delaunay <- deldir::deldir(as.data.frame(positions))

    if (verbose) message("Generating juxtaview")
    juxta.view <- seq(nrow(expr)) %>% furrr::future_map_dfr(function(cid) {
      alln <- get_neighbors(delaunay, cid)
      # suboptimal placement of dists, but makes conflict if out of scope
      # probably due to azy evaluations
      dists <- distances::distances(as.data.frame(positions))
      actualn <- alln[which(dists[alln, cid] <= neighbor.thr)]
      data.frame(t(colSums(expr[actualn, ])))
    }, .progress = verbose)

    if (cached) readr::write_rds(juxta.view, juxta.cache.file)
  }

  return(current.views %>% add_views(create_view(
    paste0("juxtaview.", neighbor.thr),
    juxta.view,
    paste0("juxta.", neighbor.thr)
  )))
}


# ncells has priority over nystrom

#' Generate and add a paraview to the current view composition
#'
#' The paraview captures the expression of all markers in  the broader
#' tissue structure.
#'
#' The paraview is generated by weighted sum of the expression of all spatial
#' units for each marker. The weights for each spatial unit \var{i} are dependent
#' on the distance to the spatial unit \var{j} and the parameter  \code{l} and are
#' calculated using the radial basis function
#' \deqn{w_{ij} = e^{-\frac{d_{ij}^2}{l^2}}}{w(i,j) = exp(-d(i,j)^2/l^2)}
#'
#' Since the generation of the paraview requires the calculation of pairwise distances
#' of all spatial units it can take a significant amount of computation time. The
#' parameters \code{approx} and \code{nn} can be set to speed up the calculation
#' by approximation. The approximation can be achieved by using the Nyström
#' low-rank approximation method or by limiting the calculation of the paraview
#' to a number of nearest neighbors around each spatial unit.
#'
#' If the value of \code{approx} is between 0 and 1 it will be interpreted as
#' fraction of the number of spatial units. Discrete values above 1 will be
#' interpreted as the size of the approximation block. The number of nearest
#' neighbors \code{nn} around each spatial unit are determined using a fast
#' nearest neighbor search.
#'
#' If both \code{approx} and \code{nn} have non-null values, \code{nn}
#' has priority and an approximation based on fast nearest neighbor
#' search will be used to generate the paraview.
#'
#' @inheritParams add_juxtaview

#' @param l effective radius of influence of expression in the broader tissue structure.
#' @param approx rank of the Nyström approximation matrix. (see Details)
#' @param nn the number of spatial units to be used for approximating the paraview
#' using a fast nearest neighbor search. (see Details)
#'
#'
#' @return A MISty view composition with added paraview with parameter \code{l}.
#'
#' @seealso \code{\link[MISTy:create_initial_view]{create_initial_view()}} for
#'     starting a view composition with an intraview only.
#'
#' @family view composition functions
#'
#' @export
add_paraview <- function(current.views, positions, l, approx = 1, nn = NULL,
                         cached = TRUE, verbose = TRUE) {
  # K.approx is a list containing C, W.plus and s (indexes of sampled columns)
  sample_nystrom_row <- function(K.approx, k) {

    # transform k into the row index of reordered K.approx
    k.ind <- which(K.approx$s == k)
    if (purrr::is_empty(k.ind)) {
      k.ind <- length(K.approx$s) + k
    }

    cw <- seq(ncol(K.approx$W.plus)) %>%
      purrr::map_dbl(~ K.approx$C[k.ind, ] %*% K.approx$W.plus[, .x])

    cwct <- seq(ncol(t(K.approx$C))) %>%
      purrr::map_dbl(~ cw %*% t(K.approx$C)[, .x])

    # reorder the columns of cwct so that they correspond to the original order
    cwct[c(K.approx$s, seq_along(cwct)[-s])]
  }

  dists <- distances::distances(as.data.frame(positions))
  expr <- current.views[["intraview"]][["data"]]

  cache.location <- paste0(
    ".misty.temp", .Platform$file.sep,
    current.views[["misty.uniqueid"]]
  )

  para.cache.file <- paste0(
    cache.location, .Platform$file.sep,
    "para.view.", l, ".rds"
  )

  if (cached & file.exists(para.cache.file)) {
    message("Paraview retrieved from cache\n")
    para.view <- readr::read_rds(para.cache.file)
  }
  else {
    if (is.null(nn)) {
      if (approx == 1) {
        if (verbose) message("Generating paraview")
        para.view <- seq(nrow(expr)) %>%
          furrr::future_map_dfr(~ data.frame(t(colSums(expr[-.x, ] *
            exp(-(dists[, .x][-.x]^2) / l^2)))),
          .options = furrr::furrr_options(packages = "distances")
          )
      }
      else {
        if (approx < 1) approx <- base::round(approx * ncol(dists))

        if (verbose) message("Approximating RBF matrix using the Nystrom method")
        # single Nystrom approximation expert, given RBF with paramter l
        s <- sort(sample.int(n = ncol(dists), size = approx))
        C <- exp(-(dists[, s]^2) / l^2)

        # pseudo inverse of W
        W.plus <- MASS::ginv(C[s, ])
        # return Nystrom list
        K.approx <- list(s = s, C = C, W.plus = W.plus)

        if (verbose) message("Generating paraview")
        para.view <- seq(nrow(expr)) %>%
          furrr::future_map_dfr(~ data.frame(t(colSums(expr[-.x, ] * sample_nystrom_row(K.approx, .x)[-.x]))))
      }
    } else {
      message("Generating paraview using ", nn, " nearest neighbors per unit")
      para.view <- seq(nrow(expr)) %>%
        furrr::future_map_dfr(function(rowid) {
          knn <- distances::nearest_neighbor_search(dists, nn + 1, query_indices = rowid)[-1, 1]
          data.frame(t(colSums(expr[knn, ] * exp(-(dists[knn, rowid]^2) / l^2))))
        }, .options = furrr::furrr_options(packages = "distances"))
    }
    if (cached) readr::write_rds(para.view, para.cache.file)
  }

  return(current.views %>% add_views(create_view(
    paste0("paraview.", l),
    para.view,
    paste0("para.", l)
  )))
}


#' Remove views from the current view composition
#'
#' Remove one or more views from the view composition.
#'
#' The intraview and the unique id cannot be removed with this function.
#'
#' @param current.views the current view composition.
#' @param view.names the names of one or more views to be removed.
#'
#' @return A MISTy view composition with \code{view.names} views removed.
#'
#' @family view composition functions
#'
#' @export
remove_views <- function(current.views, view.names) {
  to.match <- !(view.names %in% c("intraview", "misty.uniqueid"))
  view.indexes <- match(view.names[to.match], names(current.views))
  current.views %>% rlist::list.remove(view.indexes)
}
